import{Distance}from"/static/engine/code_tools/misc/Distance.js";import{List}from"/static/engine/code_tools/misc/List.js";export class Physics{constructor(){this.objects=[]}static global=new Physics;applyPhysics(t){return this.objects.push(t),t}removePhysics(t){List.remove(this.objects,t)}update(t){for(let s of this.objects){s.previousPosition={x:s.x,y:s.y};const i=1-s.weight/5e3;s.velocity.x*=Math.pow(i,t),s.velocity.y*=Math.pow(i,t),s.x+=s.velocity.x*t,s.y+=s.velocity.y*t,Math.abs(s.velocity.x)<1&&(s.velocity.x=0),Math.abs(s.velocity.y)<1&&(s.velocity.y=0)}}static applyAttraction(t,s){const i=s.x-t.x,o=s.y-t.y,c=Math.sqrt(i*i+o*o);if(c>200){const s=(c-200)/200,e=100*i/c*s,y=100*o/c*s;t.velocity.x+=e,t.velocity.y+=y}}static enforceMaxDistance(t,s){const i=s.x-t.x,o=s.y-t.y;if(Math.sqrt(i*i+o*o)>100){const c=Math.atan2(o,i),e=t.x+100*Math.cos(c),y=t.y+100*Math.sin(c),a=e-s.x,n=y-s.y;t.velocity.x-=1.1*a,t.velocity.y-=1.1*n}}static enforceMinDistance(t,s,i=100,o=.3){const c=s.x-t.x,e=s.y-t.y;if(Math.sqrt(c*c+e*e)<i){const y=Math.atan2(e,c),a=t.x+Math.cos(y)*i,n=t.y+Math.sin(y)*i,h=a-s.x,x=n-s.y;t.velocity.x-=h*o,t.velocity.y-=x*o}}followIfOutsideOfRadius(t,s){if(Distance.between(this,t)>s){const i=Math.atan2(t.y-this.y,t.x-this.x);this.x=t.x-s*Math.cos(i),this.y=t.y-s*Math.sin(i)}}}