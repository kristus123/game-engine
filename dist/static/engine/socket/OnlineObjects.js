import{AssertNotNull}from"/static/engine/assertions/AssertNotNull.js";import{Chicken}from"/static/engine/chicken_stuff/Chicken.js";import{a}from"/static/engine/code_tools/a.js";import{Collision}from"/static/engine/core/physics/Collision.js";import{Push}from"/static/engine/core/physics/Push.js";import{AllObjects}from"/static/engine/objects/AllObjects.js";import{SocketClient}from"/static/engine/socket/SocketClient.js";export class OnlineObjects extends AllObjects{constructor(e){super(),AssertNotNull(e,"argument player in "+this.constructor.name+".js should not be null"),this.player=e,this.chickens=[],this.socketClient=new SocketClient(8081,t=>{t.on("GET_GAME_OBJECTS",s=>{const o=s.gameObjects.map(e=>{const s=ObjectMapper.mapSingleObject(JSON.stringify(e));return s.removeFromGameLoop=()=>{t.send({action:"REMOVE_OBJECT",objectId:e.objectId})},s});for(const t of o)super.add(t),t instanceof Chicken&&(this.chickens.push(t),e.gun.hittableObjects.push(t))}),t.on("REMOVE_OBJECT",e=>{super.removeByObjectId(e.objectId)}),t.on("OBJECT_HANDLED_BY",e=>{super.setHandledBy(e.objectId,e.clientid)}),t.on("UPDATE_OBJECT_POSITION",e=>{const t=super.get(e.objectId);t.position.x=e.x,t.position.y=e.y})})}update(){super.updateAnd(e=>{Collision.between(e,this.player)&&this.socketClient.send({action:"OBJECT_HANDLED_BY",clientid:this.player.clientId,objectId:e.objectId}),e.handledByClientId==this.player.clientId&&this.socketClient.send({action:"UPDATE_OBJECT_POSITION",x:e.x,y:e.y,objectId:e.objectId})})}draw(e,t){super.draw(e,t)}}