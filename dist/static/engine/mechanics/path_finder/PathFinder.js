import{AssertNotNull}from"/static/engine/assertions/AssertNotNull.js";import{a}from"/static/engine/code_tools/a.js";import{List}from"/static/engine/code_tools/misc/List.js";import{Collision}from"/static/engine/core/physics/Collision.js";import{Move}from"/static/engine/core/physics/Move.js";import{LocalObjects}from"/static/engine/objects/LocalObjects.js";import{Position}from"/static/engine/position/Position.js";class PriorityQueue{constructor(t){AssertNotNull(t,"argument compare in "+this.constructor.name+".js should not be null"),this.compare=t,this.heap=[],this.compare=t}enqueue(t){this.heap.push(t),this._heapifyUp(this.heap.length-1)}dequeue(){const t=this.heap[0],e=this.heap.pop();return this.heap.length>0&&(this.heap[0]=e,this._heapifyDown(0)),t}isEmpty(){return 0===this.heap.length}_heapifyUp(t){const e=this.heap[t];for(;t>0;){const s=Math.floor((t-1)/2),o=this.heap[s];if(this.compare(e,o)>=0)break;this.heap[t]=o,t=s}this.heap[t]=e}_heapifyDown(t){const e=this.heap.length,s=this.heap[t];for(;;){const o=2*t+1,i=2*t+2;let n=null;if(o<e){const t=this.heap[o];this.compare(t,s)<0&&(n=o)}if(i<e){const t=this.heap[i];(null===n&&this.compare(t,s)<0||null!==n&&this.compare(t,this.heap[n])<0)&&(n=i)}if(null===n)break;this.heap[t]=this.heap[n],t=n}this.heap[t]=s}}const CELL_SIZE=1;function heuristic(t,e){return(Math.abs(t.x-e.x)+Math.abs(t.y-e.y))/1}function isValidPosition(t,e,s){return!isColliding(new Position(1*Math.floor(t/1),1*Math.floor(e/1),1,1),s)}function getNeighbors(t,e){const s=[];return[{x:-1,y:0},{x:1,y:0},{x:0,y:-1},{x:0,y:1}].forEach(o=>{const i=t.x+o.x,n=t.y+o.y;isValidPosition(i,n,e)&&s.push({x:i,y:n,parent:t})}),s}function astar(t,e,s,o){console.log("Starting A* pathfinding...");const i=new PriorityQueue((t,e)=>t.f-e.f),n=new Set,h={x:1*Math.floor(t.x/1),y:1*Math.floor(t.y/1),g:0,h:heuristic(t,e),f:heuristic(t,e),parent:null},a={x:1*Math.floor(e.x/1),y:1*Math.floor(e.y/1)};i.enqueue(h);const r=new Set;r.add(`${h.x},${h.y}`);const c=[];let l=0;!function t(){let e=0;for(;e<100&&!i.isEmpty();){l++;const t=i.dequeue(),h=`${t.x},${t.y}`;if(console.log(`Processing node: ${t.x}, ${t.y}. Nodes processed: ${l}`),t.x===a.x&&t.y===a.y){let e=t;for(;e;)c.push(new Position(e.x,e.y,1,1)),e=e.parent;return c.reverse(),console.log("Path found!"),void(o&&o(c))}n.add(h);getNeighbors(t,s).forEach(e=>{const s=`${e.x},${e.y}`;if(n.has(s))return;const o=t.g+1,h=heuristic(e,a),c=o+h;if(r.has(s)){const t=i.heap.find(t=>t.x===e.x&&t.y===e.y);if(t&&o>=t.g)return}e.g=o,e.h=h,e.f=c,e.parent=t,i.enqueue(e),r.add(s)}),e++}requestAnimationFrame(t)}()}function isColliding(t,e){return e.some(e=>Collision.between(t,e))}export class PathFinder{constructor(t,e,s){this.objectToMove=t,this.invisibleWalls=s,this.end=new Position(e.x,e.y,1,1),this.path=[],this.processing=!1,this.processing=!0,astar(this.objectToMove,this.end,this.invisibleWalls,t=>{this.path=t,this.processing=!1,console.log("Path update complete.")}),this.localObjects=new LocalObjects([t,e,...s])}update(){if(!this.processing&&!this.completed){if(this.path.length>0){const t=this.path.shift();this.objectToMove.x=t.x,this.objectToMove.y=t.y}0===this.path.length&&(console.log("Path completed."),this.completed=!0)}this.localObjects.update()}draw(t,e){this.localObjects.draw(t,e)}}