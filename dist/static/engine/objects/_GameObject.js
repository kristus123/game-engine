import{AssertNotNull}from"/static/engine/assertions/AssertNotNull.js";import{Distance}from"/static/engine/code_tools/misc/Distance.js";import{List}from"/static/engine/code_tools/misc/List.js";import{Random}from"/static/engine/code_tools/misc/Random.js";import{Collision}from"/static/engine/core/physics/Collision.js";export class _GameObject{constructor(t){AssertNotNull(t,"argument position in "+this.constructor.name+".js should not be null"),this.position=t,this.position=t.copy(),this._objectId=Random.uuid()}touches(t){return Collision.between(this.position,t)}touchesAny(t,i=t=>!0){for(const s of t)if(Collision.between(this.position,s)&&this!=s&&i(s))return s;return null}enforceDistance(t){const i=this.x+this.width/2,s=this.y+this.height/2,e=t.x+t.width/2-i,o=t.y+t.height/2-s,n=(this.width+t.width)/2-Math.abs(e)+1,h=(this.height+t.height)/2-Math.abs(o)+1;n>0&&h>0&&(n<h?t.x+=e>0?n:-n:t.y+=o>0?h:-h)}distance(t){return Distance.between(this,t)}closest(t){if(List.empty(t))return null;{let i=t[0];for(const s of t)this.distance(i)>this.distance(s)&&(this.closestObject=s)}return closestObject}closestWithin(t,i){let s=this.closest(i);return this.within(t,s)?s:null}within(t,i){return Distance.within(t,this,i)}notWithin(t,i){return Distance.notWithin(t,this,i)}get objectId(){return this._objectId}set objectId(t){this._objectId=t}get x(){return this.position.x}get y(){return this.position.y}set x(t){this.position.x=t}set y(t){this.position.y=t}get width(){return this.position.width}get height(){return this.position.height}set width(t){this.position.width=t}set height(t){this.position.height=t}update(){}draw(t,i){t.rectangle(this)}}