import{AssertArray}from"/static/engine/assertions/AssertArray.js";import{AssertNoNullInArray}from"/static/engine/assertions/AssertNoNullInArray.js";import{AssertNotNull}from"/static/engine/assertions/AssertNotNull.js";import{Distance}from"/static/engine/code_tools/misc/Distance.js";import{List}from"/static/engine/code_tools/misc/List.js";import{HelperThing}from"/static/engine/objects/HelperThing.js";import{Registry}from"/static/engine/objects/Registry.js";export class AllObjects{constructor(t=[]){AssertNotNull(t,"argument objects in "+this.constructor.name+".js should not be null"),this.objects=t,AssertArray(t),AssertNoNullInArray(t);for(const e of t)e.removeFromLoop=()=>{this.remove(e)},e.loop=this,e.handledBy=this,Registry.add(e)}[Symbol.iterator](){return this.objects[Symbol.iterator]()}forEach(t){return this.objects.forEach(t)}get length(){return this.objects.length}add(t){return this.objects.push(t),t.removeFromLoop=()=>{this.remove(t)},t.loop=this,t.handledBy=this,Registry.add(t),t}remove(t){List.remove(this.objects,t),Registry.remove(t)}removeByObjectId(t){for(const e of this.objects)if(e.objectId==t){List.remove(this.objects,e);break}}setHandledBy(t,e){for(const s of this.objects)if(s.objectId==t){s.handledByClientId=e;break}}get(t){return this.gameObjectFrom[t]}update(){HelperThing.update(this.objects)}updateAnd(t){HelperThing.updateAnd(this.objects,t)}draw(t,e){HelperThing.draw(this.objects,t,e)}empty(){return List.empty(this.objects)}first(){return this.objects[0]}closestTo(t,e=t=>{}){if(List.empty(this.objects))return null;let s=this.objects[0];for(const e of this.objects)Distance.between(t,e)<Distance.between(s,t)&&(s=e);return s&&e(s),s}}